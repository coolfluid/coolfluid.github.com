<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>COOLFluiD: Using Components</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="coolfluid.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">COOLFluiD
   &#160;<span id="projectnumber">Release  kernel</span>
   </div>
   <div id="projectbrief">COOLFluiD is a Collaborative Simulation Environment (CSE) focused on complex MultiPhysics simulations.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">COOLFluiD Documentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Using Components </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="_allocate"></a>
Allocating a standalone component</h1>
<p>The most basic function to allocate a component is <b><a class="el" href="namespacecf3_1_1common.html#a9e2779a644fde7b30a3a14b0775a66fe" title="Stand-alone function to allocate components of a given type. ">common::allocate_component&lt;T&gt;()</a></b>. A component is always defined by a name. </p><div class="fragment"><div class="line">boost::shared_ptr&lt;ComponentType&gt; component_ptr = common::allocate_component&lt;ComponentType&gt;(<span class="stringliteral">&quot;component_name&quot;</span>);</div>
</div><!-- fragment --><p> The return value is a boost::shared_ptr, a specialized pointer to the allocated component that keeps and shares ownership.<br />
 More information on boost::shared_ptr and why it is used can be found on the page <a class="el" href="shared_ptr_and_handles.html">Shared pointers and Handles</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It is NOT ALLOWED to create a component the following way: <div class="fragment"><div class="line">ComponentType component(<span class="stringliteral">&quot;component_name&quot;</span>);   <span class="comment">// will not compile!</span></div>
</div><!-- fragment --> This is not allowed because a boost::shared_ptr cannot be created from this object. It is always necessary to use an allocation with a boost::shared_ptr.</dd></dl>
<p><br />
 </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="shared_ptr_and_handles.html#_handle_mistake">Common mistake</a>! Don't use a <a class="el" href="classcf3_1_1_handle.html" title="Safe pointer to an object. This is the supported method for referring to components. ">Handle</a> as the return type for the <a class="el" href="namespacecf3_1_1common.html#a9e2779a644fde7b30a3a14b0775a66fe" title="Stand-alone function to allocate components of a given type. ">common::allocate_component&lt;T&gt;()</a> function!!! <div class="fragment"><div class="line">Handle&lt;ComponentType&gt; component_handle = common::allocate_component&lt;ComponentType&gt;(<span class="stringliteral">&quot;component_name&quot;</span>);  <span class="comment">// wrong! (but will compile)</span></div>
</div><!-- fragment --></dd></dl>
<h1><a class="anchor" id="_handling"></a>
Handling components</h1>
<h2><a class="anchor" id="_add_move_remove"></a>
Adding, Renaming, Moving and Removing a component</h2>
<p>If we want to nest a allocated component with name "component_name" in another existing component "parent_component", we can use the <b><a class="el" href="classcf3_1_1common_1_1_component.html#a61accf2f69ac195918f8713fdf327b3e" title="Add the passed component as a subcomponent. ">Component::add_component()</a></b> function. We want to rename the component first to "my_name"; </p><div class="fragment"><div class="line">boost::shared_ptr&lt;ComponentType&gt; component_ptr = common::allocate_component&lt;ComponentType&gt;(<span class="stringliteral">&quot;component_name&quot;</span>);</div>
<div class="line">component_ptr-&gt;rename(<span class="stringliteral">&quot;my_name&quot;</span>);</div>
<div class="line">ParentComponentType&amp; parent_component = ... ;</div>
<div class="line">parent_component.add_component(component_ptr);</div>
</div><!-- fragment --><p> This will add ownership of the allocated component stored in component_ptr to parent_component, so that when component_ptr gets deleted, the component still exists, nested in parent_component. It is possible to move a nested component from one parent to another: </p><div class="fragment"><div class="line">component_ptr-&gt;move_to(other_parent_component);</div>
</div><!-- fragment --><p> It is also possible to remove a nested component (the reverse operation of <b><a class="el" href="classcf3_1_1common_1_1_component.html#a61accf2f69ac195918f8713fdf327b3e" title="Add the passed component as a subcomponent. ">Component::add_component()</a></b> ) </p><div class="fragment"><div class="line">component_ptr = other_parent_component.remove_component(<span class="stringliteral">&quot;my_name&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="_access"></a>
Accessing a component</h1>
<h2><a class="anchor" id="_access_by_name"></a>
Access through its name</h2>
<p>When the name of the desired component is known, use the <a class="el" href="classcf3_1_1common_1_1_component.html" title="Base class for defining CF components. ">Component</a> member function <b><a class="el" href="classcf3_1_1common_1_1_component.html#a77055afffbe4082063b493c3d114b462">Component::get_child()</a></b> </p>
<div class="fragment"><div class="line">Handle&lt;Component&gt; child_component = parent_component.get_child(<span class="stringliteral">&quot;my_component&quot;</span>);</div>
</div><!-- fragment --><p>When the component needs to be cast to a known derived type (e.g. DerivedComponentType), use the <a class="el" href="classcf3_1_1common_1_1_component.html" title="Base class for defining CF components. ">Component</a> member function <a class="el" href="classcf3_1_1common_1_1_component.html#a9f63e702f1cff6775451c01a3f1c5dc4" title="Get a handle to the component. ">Component::handle&lt;T&gt;()</a> </p><div class="fragment"><div class="line">Handle&lt;DerivedComponentType&gt; child_component = parent_component.get_child(<span class="stringliteral">&quot;my_component&quot;</span>)-&gt;handle&lt;DerivedComponentType&gt;();</div>
</div><!-- fragment --><h2><a class="anchor" id="_access_by_path"></a>
Access through its path</h2>
<p>When the path of the desired component is known, use the <a class="el" href="classcf3_1_1common_1_1_component.html" title="Base class for defining CF components. ">Component</a> member function <b><a class="el" href="classcf3_1_1common_1_1_component.html#afaf216ec6c292c10d0f426e58bd0690e">Component::access_component()</a></b> Paths can be relative to the component, or global.</p>
<div class="fragment"><div class="line">Handle&lt;Component&gt; relative_component = current_component.access_component(<span class="stringliteral">&quot;../../my_component&quot;</span>);</div>
<div class="line">Handle&lt;Component&gt; absolute_component = current_component.access_component(<span class="stringliteral">&quot;/absolute/path/to/my_component&quot;</span>);</div>
</div><!-- fragment --><p>When the component needs to be cast to a known derived type (e.g. DerivedComponentType), use the <a class="el" href="classcf3_1_1common_1_1_component.html" title="Base class for defining CF components. ">Component</a> member function <a class="el" href="classcf3_1_1common_1_1_component.html#a9f63e702f1cff6775451c01a3f1c5dc4" title="Get a handle to the component. ">Component::handle&lt;T&gt;()</a> again </p><div class="fragment"><div class="line">Handle&lt;DerivedComponentType&gt; relative_component = current_component.access_component(<span class="stringliteral">&quot;../../my_component&quot;</span>)-&gt;handle&lt;DerivedComponentType&gt;();</div>
</div><!-- fragment --><p>IMPORTANT: When to access a component? Accessing a component from the tree can be a costly operation and should be avoided in loops that need to be as efficient as possible. It is therefore highly recommended to access the desired component before the loop, and create a reference to it. Several ways are widely used: </p><div class="fragment"><div class="line">Component&amp;        myComp_1 =  &lt;<span class="keyword">function</span> that returns the type <span class="stringliteral">&quot;Component&quot;</span>&gt; ;</div>
<div class="line">Handle&lt;Component&gt; myComp_2 =  &lt;<span class="keyword">function</span> that returns the type <span class="stringliteral">&quot;Component&quot;</span>&gt;.handle&lt;Component&gt;() ;</div>
<div class="line">Component&amp;        myComp_3 = *&lt;<span class="keyword">function</span> that returns the type <span class="stringliteral">&quot;Handle&lt;Component&gt;&quot;</span> ;</div>
<div class="line">Handle&lt;Component&gt; myComp_4 =  &lt;<span class="keyword">function</span> that returns the type <span class="stringliteral">&quot;Handle&lt;Component&gt;&quot;</span>&gt; ;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;1000; ++i)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// make use of myComp_1, myComp_2, myComp_3, myComp_4, myComp_5</span></div>
<div class="line">  <span class="comment">// without calling costly function that looks for a component</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Notice the "&amp;" sign, indicating that the component will not be copied, but referenced, so that the original, residing in the tree will be accessed. For myComp_2, a shared pointer of the <a class="el" href="classcf3_1_1common_1_1_component.html" title="Base class for defining CF components. ">Component</a> type is created by calling the <a class="el" href="classcf3_1_1common_1_1_component.html" title="Base class for defining CF components. ">Component</a> member function Component::self(). For myComp_3, a dereferenced version is obtained by using the asterisk to dereference the Component::Ptr. For myComp_5, a direct pointer is obtained from the shared_pointer by calling the boost::shared_ptr member function get(). Care must be taken for myComp_3 and myComp_5, if the shared_ptr is created inside the function that returns it, and if that function doesn't store the component in the component tree, as the shared_ptr will not stay alive. In that case, the component will be invalid.</p>
<p>Say you have a component "myComp" of type <a class="el" href="classcf3_1_1common_1_1_component.html" title="Base class for defining CF components. ">Component</a>. To create a subcomponent of type <a class="el" href="classcf3_1_1common_1_1_group.html" title="Component for grouping other components. ">Group</a> with name "group1" inside myComp , use <b><a class="el" href="classcf3_1_1common_1_1_component.html#aea16a3a2e514791734a21e4854485ab2" title="Build a (sub)component of this component using the extended type_name of the component. ">Component::create_component&lt;T&gt;()</a></b> function: </p><div class="fragment"><div class="line">Handle&lt;common::Group&gt; myGroup = myComp-&gt;create_component&lt;common::Group&gt;(<span class="stringliteral">&quot;group1&quot;</span>);</div>
</div><!-- fragment --><p> <a class="anchor" id="using_build_component"></a> Say you want to create a component of the abstract type <a class="el" href="classcf3_1_1mesh_1_1_mesh_reader.html">mesh::MeshReader</a>, but with concrete implementation from a gmsh reader, use then the <b><a class="el" href="namespacecf3_1_1common.html#a511b1f8ce4beee22f92b4e2b43dd6469">Component::build_component()</a></b> function </p><div class="fragment"><div class="line">Handle&lt;mesh::CMeshReader&gt; mesh_reader = </div>
<div class="line">    myComp-&gt;build_component(<span class="stringliteral">&quot;meshreader&quot;</span>,<span class="stringliteral">&quot;cf3.mesh.gmsh.Reader&quot;</span>)-&gt;handle&lt;mesh::MeshReader&gt;();</div>
</div><!-- fragment --><p> Here <code>"cf3.mesh.gmsh.Reader"</code> is the name of the concrete class <a class="el" href="classcf3_1_1mesh_1_1gmsh_1_1_reader.html">cf3::mesh::gmsh::Reader</a> The possibility of this last approach is that component creation can be configurable, as the concrete type can be passed as a string.</p>
<h1><a class="anchor" id="_configure"></a>
How to configure a component</h1>
<h2><a class="anchor" id="_config_using_code"></a>
Using c++ code</h2>
<p>Say the component "myComp" has a configuration option "My Integer Number" which is of the type "integer", then the value of option "My Integer Number" can be modified or configured using the code:</p>
<div class="fragment"><div class="line">myComp.options().configure_option( <span class="stringliteral">&quot;my_integer_number&quot;</span> , <span class="keywordtype">int</span>(2) ); </div>
</div><!-- fragment --><p>It is important to statically cast the value to the type int. Similarly for another option "My Real Number" with value of type "real" , the code would have to be: </p><div class="fragment"><div class="line">myComp.options().configure_option( <span class="stringliteral">&quot;my_real_number&quot;</span> , Real(2) );</div>
</div><!-- fragment --><p>Accessing these properties occurs using the function property(). </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>  my_integer = myComp.options().value&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;my_integer_number&quot;</span>);</div>
<div class="line">Real my_real    = myComp.options().value&lt;Real&gt;(<span class="stringliteral">&quot;my_real_number&quot;</span>);</div>
</div><!-- fragment --><p> Notice the <code>value&lt;int&gt;()</code> part in this code.</p>
<h2><a class="anchor" id="_access_by_search"></a>
Access through a search</h2>
<p>It is also possible to perform a search for components using predicates. What is returned from a search is a component iterator range. This is helpful as the iterator range can easily be used in a "boost_foreach" macro: </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> (Component&amp; component,  &lt;search <span class="keyword">function</span> returning iterator range&gt;)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// do stuff with component</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>A search function can look in a component going only one level down, or recursively traverse the whole tree of child components and its child components etc. Say we have a component tree as follows with names: </p><pre class="fragment"> root                      ( type = Root               ,  tags = )
     component1            ( type = Group              ,  tags = )
         subcomponent1     ( type = MyType             ,  tags = )
         subcomponent2     ( type = MyType             ,  tags = )
     component2            ( type = Group              ,  tags = special_tag )
         subcomponent1     ( type = MySpecializedType  ,  tags = )
         subcomponent2     ( type = MyType             ,  tags = special_tag )</pre><p> In the case we want to visit only the first level child components of root, use <b><a class="el" href="namespacecf3_1_1common.html#a7460965e48ec24d4f13bb0d2fdae1574">find_components()</a></b> : </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> ( Component&amp; component , <a class="code" href="namespacecf3_1_1common.html#a7460965e48ec24d4f13bb0d2fdae1574">find_components</a>(root_component) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// component will be in order:  component1, component2</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the &amp; since component is non-copyable, and accessing it will access the one in the tree. In the case we want to visit every component in the tree under root, use <b><a class="el" href="namespacecf3_1_1common.html#a0ea05585ce6e1d4d88599b6e8da8b458">find_components_recursively()</a></b> : </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> ( Component&amp; component , <a class="code" href="namespacecf3_1_1common.html#a0ea05585ce6e1d4d88599b6e8da8b458">find_components_recursively</a>(root_component) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// component will be in order:  component1, subcomponent1, subcomponent2, component2, subcomponent1, subcomponent2</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>There are ways to filter this range, by appending "_with_filter" , such as <a class="el" href="namespacecf3_1_1common.html#a18bb25cfa489e54aac4c0c5b766b4fb2">find_components_recursively_with_filter()</a>. The function then takes 2 arguments: first the component, and secondly a predicate. A predicate is a mini class with the operator () defined and returning true or false. Developers can create their own predicates to do advanced searches. Some built-in predicates exist such as "IsComponentName or IsComponentTag".</p>
<p>All components with name "subcomponent1" : </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> ( Component&amp; component , <a class="code" href="namespacecf3_1_1common.html#a0d33724d7aa3744f37daf8cecf0e9c80">find_components_with_filter</a>(root_component , IsComponentName(<span class="stringliteral">&quot;subcomponent1&quot;</span>) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// component will be in order:  //component1/subcomponent1 , //component2/subcomponent1</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>All components with tag "special_tag" : </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> ( Component&amp; component , <a class="code" href="namespacecf3_1_1common.html#a18bb25cfa489e54aac4c0c5b766b4fb2">find_components_recursively_with_filter</a>(root_component , IsComponentTag(<span class="stringliteral">&quot;special_tag&quot;</span>) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// component will be in order:  //component2 , //component2/subcomponent2</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>All components with tag "MyType" : </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> ( Component&amp; component , <a class="code" href="namespacecf3_1_1common.html#a18bb25cfa489e54aac4c0c5b766b4fb2">find_components_recursively_with_filter</a>(root_component , IsComponentTag(<span class="stringliteral">&quot;MyType&quot;</span>) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// component will be in order:  </span></div>
<div class="line">  <span class="comment">//   component1/subcomponent1 , component1/subcomponent2 , component2/subcomponent1 , component2/subcomponent2</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This last search is interesting as it allows to search by the type of the component. We would then of course like to use specialized functionality of that component, and it would have to be cast to the type we look for. To avoid this code, there is a templated-by-type version of every previously shown search function that automatically casts the component to the type. All you have to do is add &lt;TYPE&gt; after the find function, where "TYPE" is the type of the component you look for.</p>
<p>The last example could be rewritten to give all components of type MyType using <b><a class="el" href="namespacecf3_1_1common.html#a0ea05585ce6e1d4d88599b6e8da8b458">find_components_recursively&lt;MyType&gt;()</a></b> : </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> ( MyType&amp; component , find_components_recursively&lt;MyType&gt;(root_component) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// component is now of type MyType and will be in order:  </span></div>
<div class="line">  <span class="comment">//   component1/subcomponent1 , component1/subcomponent2 , component2/subcomponent1 , component2/subcomponent2</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that it is no longer necessary to use the "filtered" version, as this happens under the hood. It is still possible to filter on tags or names or other predicates.</p>
<p>To get the components of type MyType with extra tag "special_tag", use <b><a class="el" href="namespacecf3_1_1common.html#af644a52f2594b91a2bd23bea1b0623dc">find_components_recursively_with_tag&lt;MyType&gt;()</a></b> : </p><div class="fragment"><div class="line"><a class="code" href="_foreach_8hpp.html#a56ec391fe68d302858697046988c05ac">boost_foreach</a> ( MyType&amp; component , </div>
<div class="line">   find_components_recursively_with_tag&lt;MyType&gt;( root_component , IsComponentTag(<span class="stringliteral">&quot;special_tag&quot;</span>) ) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// component is now of type MyType , and will have the tag &quot;special_tag&quot;, and will be in order:  </span></div>
<div class="line">  <span class="comment">//   component2/subcomponent2     and NOT component2 as it is not of the type MyType </span></div>
<div class="line">  <span class="comment">//   although it also meets the IsComponentTag(&quot;special_tag&quot;) predicate</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr/>
 <ul>
<li>Next: <a class="el" href="coding_components.html">Coding your own Components</a> </li>
</ul>
</div></div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 14 2015 21:20:18 for COOLFluiD by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1</small></address>
<table width="100%">
  <tr>
    <td>
    </td>
    <td align="right" valign="center">
      Send comments to:<br>
      <a href="mailto:coolfluid@vki.ac.be">COOLFluiD Web Admin</a>
    </td>
  </tr>
</table>
</body>
</html>
