<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>COOLFluiD: Map Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="coolfluid.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">COOLFluiD
   &#160;<span id="projectnumber">Release  kernel</span>
   </div>
   <div id="projectbrief">COOLFluiD is a Collaborative Simulation Environment (CSE) focused on complex MultiPhysics simulations.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecf3.html">cf3</a></li><li class="navelem"><a class="el" href="namespacecf3_1_1common.html">common</a></li><li class="navelem"><a class="el" href="namespacecf3_1_1common_1_1_x_m_l.html">XML</a></li><li class="navelem"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html">Map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classcf3_1_1common_1_1_x_m_l_1_1_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Map Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_x_m_l_2_map_8hpp_source.html">Map.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3c551e48c77f2835810116986c05ff7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#ab3c551e48c77f2835810116986c05ff7">Map</a> (<a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> node=<a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a>())</td></tr>
<tr class="separator:ab3c551e48c77f2835810116986c05ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab050f8bac7609e21d419e7fe53532cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#ab050f8bac7609e21d419e7fe53532cdd">set_value</a> (const std::string &amp;value_key, const std::string type_name, const std::string &amp;value_str, const std::string &amp;descr=std::string())</td></tr>
<tr class="separator:ab050f8bac7609e21d419e7fe53532cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9fcd93380bfbfb98b1820cdd6fdc5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a5b9fcd93380bfbfb98b1820cdd6fdc5f">set_array</a> (const std::string &amp;value_key, const std::string element_type_name, const std::string &amp;value_str, const std::string &amp;delimiter, const std::string &amp;descr=std::string())</td></tr>
<tr class="separator:a5b9fcd93380bfbfb98b1820cdd6fdc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c26ab99dcbf4c150445eb3e1a73299f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a2c26ab99dcbf4c150445eb3e1a73299f">find_value</a> (const std::string &amp;value_key=std::string(), const char *value_type=<a class="el" href="_c_f_8hpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>) const </td></tr>
<tr class="memdesc:a2c26ab99dcbf4c150445eb3e1a73299f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a value in this map.  <a href="#a2c26ab99dcbf4c150445eb3e1a73299f">More...</a><br /></td></tr>
<tr class="separator:a2c26ab99dcbf4c150445eb3e1a73299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fff1fef365c3a4808d08640275cf6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#ac2fff1fef365c3a4808d08640275cf6e">check_entry</a> (const std::string &amp;entry_key) const </td></tr>
<tr class="memdesc:ac2fff1fef365c3a4808d08640275cf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an entry exists or not.  <a href="#ac2fff1fef365c3a4808d08640275cf6e">More...</a><br /></td></tr>
<tr class="separator:ac2fff1fef365c3a4808d08640275cf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e44c93d59e1f2c76041e6448ee3330"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a86e44c93d59e1f2c76041e6448ee3330"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a86e44c93d59e1f2c76041e6448ee3330">get_value</a> (const std::string &amp;val_key) const </td></tr>
<tr class="separator:a86e44c93d59e1f2c76041e6448ee3330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9546beada93ad704d30383d6d707be21"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a9546beada93ad704d30383d6d707be21"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a9546beada93ad704d30383d6d707be21">get_array</a> (const std::string &amp;val_key) const </td></tr>
<tr class="separator:a9546beada93ad704d30383d6d707be21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725520e0f870e93f195cc5a8a686da4a"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a725520e0f870e93f195cc5a8a686da4a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a725520e0f870e93f195cc5a8a686da4a">array_to_vector</a> (const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;array_node, std::string *delim=<a class="el" href="_c_f_8hpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>) const </td></tr>
<tr class="separator:a725520e0f870e93f195cc5a8a686da4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5a4be7b05fefdd982608bc83e37ac16"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#ad5a4be7b05fefdd982608bc83e37ac16">is_single_value</a> (const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;node)</td></tr>
<tr class="separator:ad5a4be7b05fefdd982608bc83e37ac16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27c18aa643b4da179a8fbc5300c7617"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#af27c18aa643b4da179a8fbc5300c7617">is_array_value</a> (const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;node)</td></tr>
<tr class="separator:af27c18aa643b4da179a8fbc5300c7617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b307ef52835472cb4f3244929e7e1b2"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a3b307ef52835472cb4f3244929e7e1b2">get_value_type</a> (const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;node)</td></tr>
<tr class="separator:a3b307ef52835472cb4f3244929e7e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6963cb6a561054651781b088e1646def"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a6963cb6a561054651781b088e1646def"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a6963cb6a561054651781b088e1646def">split_string</a> (const std::string &amp;str, const std::string &amp;delimiter, std::vector&lt; TYPE &gt; &amp;result, int size=-1)</td></tr>
<tr class="separator:a6963cb6a561054651781b088e1646def"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae65e3cd301d0770d352ac09afd427293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#ae65e3cd301d0770d352ac09afd427293">content</a></td></tr>
<tr class="memdesc:ae65e3cd301d0770d352ac09afd427293"><td class="mdescLeft">&#160;</td><td class="mdescRight">The managed node.  <a href="#ae65e3cd301d0770d352ac09afd427293">More...</a><br /></td></tr>
<tr class="separator:ae65e3cd301d0770d352ac09afd427293"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a3644527ca0717d5305ba0f616e362d49"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a3644527ca0717d5305ba0f616e362d49"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a3644527ca0717d5305ba0f616e362d49">value_has_ptr</a> (const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;node)</td></tr>
<tr class="separator:a3644527ca0717d5305ba0f616e362d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages maps in a <a class="el" href="namespacecf3_1_1common_1_1_x_m_l.html" title="Classes that implement the XML protocol for use in COOLFluiD. ">XML</a> tree. A map is an associative container of values: it contains values identified by a unique name (the "key"). Each value can contain another map. There are two kind of values: single values and array values. Single values contain only one value of a certain type and array ones may contain several values (each of the same type). <br />
 A value has an assigned type (one of those supported by <code>#from_value()</code> ) which cannot be changed (from example, a <code>bool</code> value cannot be changed to <code>int</code>). An existing value can be modified using <code><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#ab050f8bac7609e21d419e7fe53532cdd">set_value()</a></code> or <code><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html#a5b9fcd93380bfbfb98b1820cdd6fdc5f">set_array()</a></code>. If it does not exist, these function automatically add it.<br />
 A value can have a restricted list of values. This is an array that defines the acceptable values. Setting a restricted to value is the same as setting a array to it.</p><dl class="section author"><dt>Author</dt><dd>Quentin Gasper. </dd></dl>

<p>Definition at line <a class="el" href="_x_m_l_2_map_8hpp_source.html#l00038">38</a> of file <a class="el" href="_x_m_l_2_map_8hpp_source.html">Map.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab3c551e48c77f2835810116986c05ff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_map.html">Map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a>&#160;</td>
          <td class="paramname"><em>node</em> = <code><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to manage. Must be valid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00144">144</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a725520e0f870e93f195cc5a8a686da4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; TYPE &gt; array_to_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>array_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>delim</em> = <code><a class="el" href="_c_f_8hpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an array <a class="el" href="namespacecf3_1_1common_1_1_x_m_l.html" title="Classes that implement the XML protocol for use in COOLFluiD. ">XML</a> node to a vector of TYPE </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array_node</td><td>The array node to convert. Must be valid. </td></tr>
    <tr><td class="paramname">delim</td><td>A pointer a string where the delimiter will be stored. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_xml_error.html">XmlError</a></td><td>if no delimiter is found. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_parsing_failed.html">ParsingFailed</a></td><td>if no size is found or if the found size does not match with the number of found elements. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00401">401</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2fff1fef365c3a4808d08640275cf6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool check_entry </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>entry_key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether an entry exists or not. </p>
<p>An entry can be either a single value, or a map. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_key</td><td>The entry name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the entry was found. </dd></dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00258">258</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c26ab99dcbf4c150445eb3e1a73299f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> find_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_key</em> = <code>std::string()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value_type</em> = <code><a class="el" href="_c_f_8hpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a value in this map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_key</td><td>The key (name) of the wanted value. May be empty. </td></tr>
    <tr><td class="paramname">value_type</td><td>The value type (single value or array). Three values are accepted : <code><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_protocol_1_1_tags.html#a16bb1ebfa99498a25c025eaf743880ca">Protocol::Tags::node_value()</a></code> (for a value), <code><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_protocol_1_1_tags.html#a9c40089a19937eb1d6e68c1af9c00452">Protocol::Tags::node_array()</a></code> (for an array) and an empty string (any type). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the first value found with the key. If the key is empty, returns the first value found in the map. Otherwise, returns a null pointer. If <code>value_type</code> is not valid, a null pointer is returned as well. </dd></dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00311">311</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9546beada93ad704d30383d6d707be21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; TYPE &gt; get_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val_key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches an array in the provided map and converts it to std::vector&lt;TYPE&gt;. </p><dl class="section note"><dt>Note</dt><dd>This function can be used to get a restricted list of a value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map under which the array has to searched for. </td></tr>
    <tr><td class="paramname">val_key</td><td>The array key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a vector containing the array values. The vector might be empty as the array may have no value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_bad_value.html">BadValue</a></td><td>If the value key is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_xml_error.html">XmlError</a></td><td>If no value with that key and value was found. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00374">374</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86e44c93d59e1f2c76041e6448ee3330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TYPE get_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>val_key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches a value in the provided map and converts it to TYPE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The map. </td></tr>
    <tr><td class="paramname">val_key</td><td>The value key (name). Cannot be empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the converted value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_bad_value.html">BadValue</a></td><td>If the value key is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_xml_error.html">XmlError</a></td><td>If no value with that key and value was found. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00349">349</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b307ef52835472cb4f3244929e7e1b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * get_value_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gives the type name of a provided value node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to process. Must be valid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a C-string with the type name. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function does not check whether the </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_xml_error.html">XmlError</a></td><td>If <ul>
<li>the node is neither a single nor an array value </li>
<li>no type was found inside the node </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00281">281</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af27c18aa643b4da179a8fbc5300c7617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_array_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the provided node represents an array value. </p><dl class="section note"><dt>Note</dt><dd>This function does not check the validity of the <a class="el" href="namespacecf3_1_1common_1_1_x_m_l.html" title="Classes that implement the XML protocol for use in COOLFluiD. ">XML</a> representation (i.e. it doesn't check that the type exists or is valid,...). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the node represents a array value. Otherwise, returns <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00274">274</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5a4be7b05fefdd982608bc83e37ac16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_single_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the provided node represents a single value. </p><dl class="section note"><dt>Note</dt><dd>This function does not check the validity of the <a class="el" href="namespacecf3_1_1common_1_1_x_m_l.html" title="Classes that implement the XML protocol for use in COOLFluiD. ">XML</a> representation (i.e. it doesn't check that the type exists or is valid,...). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the node represents a single value. Otherwise, returns <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00267">267</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b9fcd93380bfbfb98b1820cdd6fdc5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> set_array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>element_type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>descr</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds or modifies an array value. The TYPE must be one of those supported by <code>#from_value()</code>. If no value with the provided key exists, a single value is created. If it already exists <b>and</b> is a single value, it is modified. An array value cannot be modified as a single one. <br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_key</td><td>The value key (name). Cannot be empty. </td></tr>
    <tr><td class="paramname">type_name</td><td>The string description of the type of a single element </td></tr>
    <tr><td class="paramname">value_str</td><td>The value, as string, for the entire array </td></tr>
    <tr><td class="paramname">descr</td><td>Description</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_bad_value.html">BadValue</a></td><td>If the value key is empty. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00197">197</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab050f8bac7609e21d419e7fe53532cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> set_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>descr</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds or modifies a value. The TYPE must be one of those supported by <code>#from_value()</code>. If no value with the provided key exists, a single value is created. If it already exists <b>and</b> is a single value, it is modified. An array value cannot be modified as a single one. <br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value_key</td><td>The value key (name). Cannot be empty. </td></tr>
    <tr><td class="paramname">type_name</td><td>The string description of the type </td></tr>
    <tr><td class="paramname">value_str</td><td>The value, as string </td></tr>
    <tr><td class="paramname">descr</td><td>Description </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_bad_value.html">BadValue</a></td><td>If the value key is empty. </td></tr>
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_xml_error.html">XmlError</a></td><td>if <ul>
<li>the value exists and is an array </li>
<li>the value exists and its type does not match to TYPE </li>
<li>the value exists but does not have a type </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00152">152</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6963cb6a561054651781b088e1646def"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void split_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits a string and casts each resulting part to TYPE. This function can whether the number of elements to read is known or or not. If the size is known the provided vector is cleared and initialized to contain this number of items. This way is more efficient, of course, because there is no reallocation needed. If the size if not defined, elements are appended to the vector by using <code>push_back()</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The string that delimitates the parts. It will not appear in the <code>result</code>. </td></tr>
    <tr><td class="paramname">result</td><td>The vector where cast parts are stored. </td></tr>
    <tr><td class="paramname">size</td><td>If greater or equal to 0, gives the number of elements to read. Otherwise, the vector is reallocated as the elements are added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structcf3_1_1common_1_1_casting_failed.html">CastingFailed</a></td><td>If an item cannot be cast to TYPE. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00079">79</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3644527ca0717d5305ba0f616e362d49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool value_has_ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks whether the provided has the type TYPE. This function can be called for both single and array values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <code>true</code> if the value has the correct type. Otherwise, or if the node is not valid or is neither a signle value nor an array value, returns <code>false</code>. </dd></dl>

<p>Definition at line <a class="el" href="_map_8cpp_source.html#l00437">437</a> of file <a class="el" href="_map_8cpp_source.html">Map.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae65e3cd301d0770d352ac09afd427293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcf3_1_1common_1_1_x_m_l_1_1_xml_node.html">XmlNode</a> content</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The managed node. </p>

<p>Definition at line <a class="el" href="_x_m_l_2_map_8hpp_source.html#l00179">179</a> of file <a class="el" href="_x_m_l_2_map_8hpp_source.html">Map.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>cf3/common/XML/<a class="el" href="_x_m_l_2_map_8hpp_source.html">Map.hpp</a></li>
<li>cf3/common/XML/<a class="el" href="_map_8cpp_source.html">Map.cpp</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 14 2015 21:20:19 for COOLFluiD by&nbsp;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1</small></address>
<table width="100%">
  <tr>
    <td>
    </td>
    <td align="right" valign="center">
      Send comments to:<br>
      <a href="mailto:coolfluid@vki.ac.be">COOLFluiD Web Admin</a>
    </td>
  </tr>
</table>
</body>
</html>
